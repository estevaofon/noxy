// stdlib/http_parser.nx - Parser HTTP/1.1

use strings select *

// ============================================
// Estruturas de Dados
// ============================================

struct HttpRequest
    method: string,           // "GET", "POST", etc
    path: string,             // "/api/users"
    query: string,            // "id=123&name=test" (sem o '?')
    version: string,          // "HTTP/1.1"
    headers: string[64],      // Array de headers "Name: Value"
    header_count: int,        // Numero de headers validos
    body: bytes               // Corpo da requisicao
end

struct HttpResponse
    version: string,          // "HTTP/1.1"
    status_code: int,         // 200, 404, 500, etc
    status_text: string,      // "OK", "Not Found", etc
    headers: string[64],      // Array de headers
    header_count: int,
    body: bytes
end

struct HttpUrl
    scheme: string,           // "http" ou "https"
    host: string,             // "api.example.com"
    port: int,                // 80, 443, 8080, etc
    path: string,             // "/api/users"
    query: string,            // "id=123" (sem o '?')
    fragment: string,         // "section1" (sem o '#')
    valid: bool               // true se parse OK
end

// ============================================
// Constantes e Helpers
// ============================================

// Status codes comuns
let HTTP_200_OK: int = 200
let HTTP_201_CREATED: int = 201
let HTTP_204_NO_CONTENT: int = 204
let HTTP_400_BAD_REQUEST: int = 400
let HTTP_404_NOT_FOUND: int = 404
let HTTP_500_INTERNAL_ERROR: int = 500

// Content-Type comuns
let CONTENT_TYPE_JSON: string = "application/json"
let CONTENT_TYPE_HTML: string = "text/html"
let CONTENT_TYPE_TEXT: string = "text/plain"
let CONTENT_TYPE_CSS: string = "text/css"
let CONTENT_TYPE_JS: string = "application/javascript"
let CONTENT_TYPE_PNG: string = "image/png"
let CONTENT_TYPE_JPEG: string = "image/jpeg"

func get_status_text(code: int) -> string
    if code == 200 then return "OK" end
    if code == 201 then return "Created" end
    if code == 204 then return "No Content" end
    if code == 400 then return "Bad Request" end
    if code == 401 then return "Unauthorized" end
    if code == 403 then return "Forbidden" end
    if code == 404 then return "Not Found" end
    if code == 500 then return "Internal Server Error" end
    if code == 502 then return "Bad Gateway" end
    if code == 503 then return "Service Unavailable" end
    return "Unknown"
end

// Encontra proxima ocorrencia de \r\n (13, 10 bytes)
// Retorna -1 se nao encontrar
func find_crlf(data: bytes, start: int, len: int) -> int
    let i: int = start
    while i < len - 1 do
        // Checando manualmente os bytes para CR (13) e LF (10)
        // Como o tipo e bytes, acesso por indice retorna int (byte value)
        if data[i] == 13 then
            if data[i+1] == 10 then
                return i
            end
        end
        i = i + 1
    end
    return -1
end

// Helper para converter sub-sequencia de bytes para string
// Assumindo to_str converte bytes inteiros, entao vamos fatiar
func bytes_to_string(data: bytes, start: int, end_idx: int) -> string
    // slice(bytes, start, end) -> bytes
    // to_str(bytes) -> string (decodifica)
    let sub: bytes = slice(data, start, end_idx)
    return to_str(sub)
end

// Helper para converter string para bytes
func string_to_bytes(s: string) -> bytes
    return to_bytes(s)
end

// Helper para trim de espacos (simplificado)
func trim(s: string) -> string
    if length(s) == 0 then return "" end
    
    // Simplificacao: apenas retorna a string por enquanto
    // Noxy nao tem suporte facil a checar isspace char a char ainda
    // Se necessario, implementar checagem de ' ' e '\t'
    return s
end

// ============================================
// Parse de URL
// ============================================

func parse_url(url: string) -> HttpUrl
    let res: HttpUrl = HttpUrl("http", "", 80, "/", "", "", false)
    
    if length(url) == 0 then return res end
    
    let current: string = url
    
    // 1. Scheme
    let split_scheme: SplitResult = split(current, "://")
    if split_scheme.count > 1 then
        res.scheme = split_scheme.parts[0]
        current = split_scheme.parts[1]
    end
    
    // Define porta padrao baseada no scheme
    if res.scheme == "https" then
        res.port = 443
    else
        res.port = 80
    end
    
    // 2. Fragment (#)
    let split_frag: SplitResult = split(current, "#")
    if split_frag.count > 1 then
        res.fragment = split_frag.parts[1]
        current = split_frag.parts[0]
    end
    
    // 3. Query (?)
    let split_query: SplitResult = split(current, "?")
    if split_query.count > 1 then
        res.query = split_query.parts[1]
        current = split_query.parts[0]
    end
    
    // 4. Path e Authority
    // A string restante em 'current' tem formato "host:port/path" ou "host/path"
    
    // Separa no primeiro '/'
    let split_path: SplitResult = split(current, "/")
    let authority: string = split_path.parts[0]
    
    if split_path.count > 1 then
        res.path = "/" + split_path.parts[1]
    else
        res.path = "/"
    end
    
    // 5. Host e Port (Authority)
    let split_port: SplitResult = split(authority, ":")
    if split_port.count > 1 then
        res.host = split_port.parts[0]
        res.port = to_int(split_port.parts[1])
    else
        res.host = authority
    end
    
    res.valid = true
    return res
end

// ============================================
// Parse Request/Response
// ============================================

func parse_headers(raw_str: string) -> string[64]
    let headers: string[64]
    // Nao temos split_lines facil, vamos processar linha a linha manualmente ou assumir que ja temos vetor?
    // A funcao parse_request vai processar linha a linha a partir dos bytes.
    return headers
end

func parse_request(raw_data: bytes, data_len: int) -> HttpRequest
    let req: HttpRequest = HttpRequest("GET", "/", "", "HTTP/1.1", [], 0, b"")
    
    // 1. Processar Request Line e Headers
    // Vamos iterar procurando CRLF
    
    let cursor: int = 0
    let line_start: int = 0
    let is_body: bool = false
    let line_count: int = 0
    
    let empty_headers: string[64] // Inicializa array vazio
    req.headers = empty_headers
    
    while cursor < data_len do
        let crlf_pos: int = find_crlf(raw_data, cursor, data_len)
        
        if crlf_pos == -1 then
            // Sem mais CRLF, o resto e body ou fim
            if !is_body then
                // Se ainda estavamos nos headers, algo errado ou fim abrupto
                // Assumimos resto como body se tiver algo
                if cursor < data_len then
                   req.body = slice(raw_data, cursor, data_len) 
                end
            end
            break // Sai do loop
        end
        
        // Temos uma linha de cursor ate crlf_pos
        
        // Verifica linha vazia (fim dos headers)
        if crlf_pos == cursor then
            is_body = true
            // Pula o CRLF
            cursor = crlf_pos + 2
            // O resto e body
            if cursor < data_len then
                req.body = slice(raw_data, cursor, data_len)
            end
            break // Terminou parse
        end
        
        // Processa linha
        let line_str: string = bytes_to_string(raw_data, cursor, crlf_pos)
        
        if line_count == 0 then
            // Request Line: GET /path HTTP/1.1
            let split1: SplitResult = split(line_str, " ")
            req.method = split1.parts[0]
            
            let remainder: string = ""
            if split1.count > 1 then remainder = split1.parts[1] end
            let split2: SplitResult = split(remainder, " ")
            let full_path: string = split2.parts[0]
            if split2.count > 1 then
                req.version = split2.parts[1]
            else
                req.version = "HTTP/1.1"
            end
            
            // Separa path e query
            let split_q: SplitResult = split(full_path, "?")
            req.path = split_q.parts[0]
            if split_q.count > 1 then
                req.query = split_q.parts[1]
            else
                req.query = ""
            end
            
        else
            // Header: Name: Value
            // Armazena string inteira por enquanto, conforme struct "Name: Value"
            if req.header_count < 64 then
                req.headers[req.header_count] = line_str
                req.header_count = req.header_count + 1
            end
        end
        
        line_count = line_count + 1
        cursor = crlf_pos + 2 // Avanca apos \r\n
    end
    
    return req
end

func parse_response(raw_data: bytes, data_len: int) -> HttpResponse
    let resp: HttpResponse = HttpResponse("HTTP/1.1", 200, "OK", [], 0, b"")
    
    let cursor: int = 0
    let is_body: bool = false
    let line_count: int = 0
    
    let empty_headers: string[64]
    resp.headers = empty_headers
    
    while cursor < data_len do
        let crlf_pos: int = find_crlf(raw_data, cursor, data_len)
        
        if crlf_pos == -1 then
            if !is_body & (cursor < data_len) then
                resp.body = slice(raw_data, cursor, data_len)
            end
            break
        end
        
        if crlf_pos == cursor then
            is_body = true
            cursor = crlf_pos + 2
            if cursor < data_len then
                resp.body = slice(raw_data, cursor, data_len)
            end
            break
        end
        
        let line_str: string = bytes_to_string(raw_data, cursor, crlf_pos)
        
        if line_count == 0 then
            // Status Line: HTTP/1.1 200 OK
            let split1: SplitResult = split(line_str, " ")
            resp.version = split1.parts[0]
            
            let remainder: string = ""
            if split1.count > 1 then remainder = split1.parts[1] end
            let split2: SplitResult = split(remainder, " ")
            
            // O codigo pode nao ter texto depois
            resp.status_code = to_int(split2.parts[0])
            if split2.count > 1 then
                resp.status_text = split2.parts[1]
            else
                resp.status_text = ""
            end
            
        else
            if resp.header_count < 64 then
                resp.headers[resp.header_count] = line_str
                resp.header_count = resp.header_count + 1
            end
        end
        
        line_count = line_count + 1
        cursor = crlf_pos + 2
    end
    
    return resp
end

// ============================================
// Build Request/Response
// ============================================

func build_request(method: string, path: string, headers: string[64], header_count: int, body: bytes) -> bytes
    let req_str: string = method + " " + path + " HTTP/1.1\r\n"
    
    let i: int = 0
    while i < header_count do
        req_str = req_str + headers[i] + "\r\n"
        i = i + 1
    end
    
    req_str = req_str + "\r\n"
    
    let head_bytes: bytes = to_bytes(req_str)
    
    // Concatena head e body
    return head_bytes + body
end

func build_response(status_code: int, status_text: string, headers: string[64], header_count: int, body: bytes) -> bytes
    let status_line: string = "HTTP/1.1 " + to_str(status_code) + " " + status_text + "\r\n"
    let resp_str: string = status_line
    
    let i: int = 0
    while i < header_count do
        resp_str = resp_str + headers[i] + "\r\n"
        i = i + 1
    end
    
    resp_str = resp_str + "\r\n"
    
    let head_bytes: bytes = to_bytes(resp_str)
    return head_bytes + body
end

// ============================================
// Header Manipulation
// ============================================

func get_header(req: ref HttpRequest, name: string) -> string
    let search: string = name + ":"
    // Simplificado: case sensitive por enquanto no prefixo, 
    // mas ideal seria case-insensitive
    
    let i: int = 0
    while i < req.header_count do
        // Checagem "contains" ou starts with manual?
        // Vamos usar uma abordagem simples: name + ":"
        // Deveria normalizar para lower case
        
        let header_line: string = req.headers[i]
        
        // Verifica se comeca com name:
        // Como nao temos starts_with ainda ou lower(), vamos fazer um check manual basico
        // ou usar substring
        if length(header_line) > length(search) then
            let prefix: string = substring(header_line, 0, length(search))
            // Se for igual (case sensitive aqui :/) 
            if prefix == search then
                let split_h: SplitResult = split(header_line, ":")
                if split_h.count > 1 then return trim(split_h.parts[1]) end
            end
        end
        i = i + 1
    end
    
    return ""
end

func set_header(headers: ref string[64], header_count: ref int, name: string, value: string) -> void
    if header_count < 64 then
        headers[header_count] = name + ": " + value
        header_count = header_count + 1
    end
end
