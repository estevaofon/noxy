use http_server select *
use http_parser select *
use net select *
use io
use sqlite
use strings select *

use sys select *

// ============================================
// Database Setup
// ============================================

let db: sqlite.Database = sqlite.open("todo.db")

func init_db() -> void
    if !db.open then
        print("Failed to open database 'todo.db'")
        return
    end

    // Create table if not exists
    // completed: 0 = false, 1 = true
    let sql: string = "CREATE TABLE IF NOT EXISTS todos (id INTEGER PRIMARY KEY, title TEXT, completed INTEGER)"
    let res: sqlite.ExecResult = sqlite.execute(db, sql)
    
    if !res.ok then
        print("DB Init Error: " + res.error)
    else
        print("Database initialized.")
    end
end

// ============================================
// Handlers
// ============================================


struct TodoItem
    id: int
    title: string
    completed: int
end

func handle_get_todos() -> HttpResponse
    let sql_query: string = "SELECT id, title, completed FROM todos"
    let res: sqlite.QueryResult = sqlite.query(db, sql_query)
    
    if !res.ok then
        return response_error(500, "DB Error: " + res.error)
    end
    
    let items: TodoItem[]
    let count: int = 0
    
    let i: int = 0
    while i < res.row_count do
        if count >= 100 then
            break
        end
        
        let row: Row = res.rows[i]
        let item: TodoItem = TodoItem(row.values[0], row.values[1], row.values[2])
        append(items, item)
        count = count + 1
        i = i + 1
    end
    
    return response_json(json_dumps(items))
end


struct AddTodoRequest
    title: string
end

func handle_add_todo(body: bytes) -> HttpResponse
    let json_str: string = to_str(body)
    let req: AddTodoRequest = AddTodoRequest("")
    if !json_loads(json_str, ref req) then
         return response_error(400, "Invalid JSON")
    end
    
    if is_empty(req.title) then
        return response_error(400, "Missing title")
    end
    
    let stmt: sqlite.Statement = sqlite.prepare(db, "INSERT INTO todos (title, completed) VALUES (?, 0)")
    sqlite.bind_text(stmt, 1, req.title)
    let res: sqlite.ExecResult = sqlite.step_exec(stmt)
    sqlite.finalize(stmt)
    
    if !res.ok then
        return response_error(500, "Failed to insert: " + res.error)
    end
    
    let resp: map = {"status": "ok", "id": res.last_insert_id}
    return response_json(json_dumps(resp))
end


struct DeleteTodoRequest
    id: int
end

func handle_toggle_todo(body: bytes) -> HttpResponse
    let json_str: string = to_str(body)
    let req: DeleteTodoRequest = DeleteTodoRequest(0) // Reuse reuse struct for toggle as it also needs ID only
    
    if !json_loads(json_str, ref req) then
        return response_error(400, "Invalid JSON")
    end
    
    let sql: string = "UPDATE todos SET completed = CASE WHEN completed = 0 THEN 1 ELSE 0 END WHERE id = ?"
    let stmt: sqlite.Statement = sqlite.prepare(db, sql)
    sqlite.bind_int(stmt, 1, req.id)
    let res: sqlite.ExecResult = sqlite.step_exec(stmt)
    sqlite.finalize(stmt)
    
    if !res.ok then
        return response_error(500, "DB Error")
    end
    
    let resp: map = {"status": "ok"}
    return response_json(json_dumps(resp))
end

func handle_delete_todo(body: bytes) -> HttpResponse
    let json_str: string = to_str(body)
    let req: DeleteTodoRequest = DeleteTodoRequest(0)
    
    if !json_loads(json_str, ref req) then
        return response_error(400, "Invalid JSON")
    end
    
    let stmt: sqlite.Statement = sqlite.prepare(db, "DELETE FROM todos WHERE id = ?")
    sqlite.bind_int(stmt, 1, req.id)
    let res: sqlite.ExecResult = sqlite.step_exec(stmt)
    sqlite.finalize(stmt)
    
    if !res.ok then
        return response_error(500, "DB Error")
    end
    
    let resp: map = {"status": "ok"}
    return response_json(json_dumps(resp))
end

// ============================================
// Router
// ============================================

func handle_request(req: HttpRequest) -> HttpResponse
    print(req.method + " " + req.path)
    
    if req.method == "GET" then
        if req.path == "/" then
            return serve_file("noxy_examples/static/index.html")
        end
        if req.path == "/api/todos" then
            return handle_get_todos()
        end
    end
    
    if req.method == "POST" then
        if req.path == "/api/todos" then
            return handle_add_todo(req.body)
        end
    end
    
    if req.method == "PUT" then
        if req.path == "/api/todos/toggle" then
            return handle_toggle_todo(req.body)
        end
    end
    
    if req.method == "DELETE" then
        if req.path == "/api/todos/delete" then
            return handle_delete_todo(req.body)
        end
    end
    
    return response_error(404, "Not Found")
end

// ============================================
// Main
// ============================================

init_db()

// Get PORT from environment or default to 8080
let port_str: string = getenv("PORT").value
let port: int = 8080
if !is_empty(port_str) then
    port = to_int(port_str)
end

//let server: HttpServer = new_server("0.0.0.0", port)
let host: string = "127.0.0.1"
let server: HttpServer = new_server(host, port)

if start(server) then
    print(f"TODO Server running at {host}:" + to_str(port) + "/")
    
    while true do
        let event: RequestEvent = server_poll(server)
        
        if event.type == "REQUEST" then
            let resp: HttpResponse = handle_request(event.request)
            server_send(server, event.client_index, resp)
        end
    end
else
    print("Failed to start server")
end

close(db)
