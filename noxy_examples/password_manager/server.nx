use http_server
use http_parser
use io
use sqlite
use strings
use time
use crypto

// No need for 'use json' if they are built-ins, but if it fails I'll add it.
// Assuming they are global per instructions.

// ============================================
// Data Structures
// ============================================

struct PasswordRequest
    title: string
    username: string
    password: string
end

struct PasswordEntry
    id: int
    title: string
    username: string
    password: string
    created_at: string
end

// ============================================
// Database Setup
// ============================================

let db: sqlite.Database = sqlite.open("passwords.db")

if !db.open then
    print("Failed to open passwords.db")
    return
end

let init_sql: string = "CREATE TABLE IF NOT EXISTS passwords (id INTEGER PRIMARY KEY, title TEXT, username TEXT, encrypted_password TEXT, created_at TEXT)"
let res: sqlite.ExecResult = sqlite.exec(db, init_sql)

if !res.ok then
    print("Failed to create table: " + res.error)
    return
end

print("Password Manager Database Opened successfully.")

// ============================================
// Encryption Logic (AES-256-GCM + PBKDF2)
// ============================================

let VAULT_FILE: string = "vault.key"
let ITERATIONS: int = 200000
let KEY_SIZE: int = 32

// Chave derivada (inicializada no startup)
let master_key: bytes = b""
let vault_salt: bytes = b""

// Inicializa a chave mestra a partir da senha
func init_master_key(password: string) -> bool
    // Verificar se vault.key existe (contém salt)
    let f: io.File = io.open("noxy_examples/password_manager/" + VAULT_FILE, "r")
    
    if f.open then
        // Vault existe - ler salt
        let res: io.IOBytesResult = io.read_bytes(f)
        io.close(f)
        if res.ok then
            vault_salt = res.data
        else
            return false
        end
    else
        // Novo vault - gerar salt
        vault_salt = crypto.random_bytes(16)
        let fw: io.File = io.open("noxy_examples/password_manager/" + VAULT_FILE, "w")
        if fw.open then
            io.write(fw, to_str(vault_salt))
            io.close(fw)
            print("Novo vault criado com salt seguro.")
        else
            print("Erro ao criar vault.key")
            return false
        end
    end
    
    // Derivar chave da senha
    master_key = crypto.pbkdf2_sha256(password, vault_salt, ITERATIONS, KEY_SIZE)
    return true
end

func encrypt(plain: string) -> string
    if master_key == b"" then
        print("ERRO: master_key não inicializada!")
        return ""
    end
    let plain_bytes: bytes = to_bytes(plain)
    let encrypted: bytes = crypto.aes256_gcm_encrypt(master_key, plain_bytes)
    return hex_encode(encrypted)
end

func decrypt(hex_str: string) -> string
    if master_key == b"" then
        print("ERRO: master_key não inicializada!")
        return ""
    end
    let encrypted_bytes: bytes = hex_decode(hex_str)
    let decrypted: bytes = crypto.aes256_gcm_decrypt(master_key, encrypted_bytes)
    if decrypted == null then
        return "[ERRO: falha na descriptografia]"
    end
    return to_str(decrypted)
end

// ============================================
// Helpers
// ============================================

func read_file(path: string) -> string
    let f: io.File = io.open("noxy_examples/password_manager/" + path, "r")
    if !f.open then return "" end
    let res: io.IOResult = io.read(f)
    io.close(f)
    if res.ok then return res.data end
    return ""
end

// ============================================
// Handlers
// ============================================

func handle_save_password(body: bytes) -> http_parser.HttpResponse
    let json_str: string = to_str(body)
    
    // Usage of json_loads
    let req: PasswordRequest = PasswordRequest("", "", "")
    
    // Tries to populate 'req' from 'json_str'
    if !json_loads(json_str, ref req) then
        return http_server.response_error(400, "Invalid JSON")
    end
    
    if strings.is_empty(req.title) || strings.is_empty(req.password) then
        return http_server.response_error(400, "Missing title or password")
    end
    
    let encrypted_pass: string = encrypt(req.password)
    let created_at: string = time.format(time.now_datetime())
    
    let params: any[]
    append(params, req.title)
    append(params, req.username)
    append(params, encrypted_pass)
    append(params, created_at)
    
    let res: sqlite.ExecResult = sqlite.execute_params(db, "INSERT INTO passwords (title, username, encrypted_password, created_at) VALUES (?, ?, ?, ?)", params)
    
    if res == null || !res.ok then
        return http_server.response_error(500, "DB Error: " + res.error)
    end
    
    // Return simple JSON response
    return http_server.response_json("{\"status\": \"ok\", \"id\": " + to_str(res.last_insert_id) + "}")
end

func handle_list_passwords() -> http_parser.HttpResponse
    let res: sqlite.QueryResult = sqlite.query(db, "SELECT id, title, username, encrypted_password, created_at FROM passwords ORDER BY id DESC")
    
    if res == null || !res.ok then
        return http_server.response_error(500, "DB Query Error")
    end
    
    let items: PasswordEntry[]
    
    let i: int = 0
    while i < res.row_count do
        let row: sqlite.Row = res.rows[i]
        
        let id_val: string = row.values[0]
        let title: string = row.values[1]
        let username: string = row.values[2]
        let enc_pass: string = row.values[3]
        let created_at: string = row.values[4]
        
        let dec_pass: string = decrypt(enc_pass)
        
        let entry: PasswordEntry = PasswordEntry(to_int(id_val), title, username, dec_pass, created_at)
        append(items, entry)
        
        i = i + 1
    end
    
    // Native json_dumps for array of structs
    let json_resp: string = json_dumps(items)
    return http_server.response_json(json_resp)
end

func handle_delete_password(id_str: string) -> http_parser.HttpResponse
    let id: int = to_int(id_str)
    if id <= 0 then
        return http_server.response_error(400, "Invalid ID")
    end
    
    let sql: string = "DELETE FROM passwords WHERE id = " + id_str
    let res: sqlite.ExecResult = sqlite.exec(db, sql)
    
    if !res.ok then
        return http_server.response_error(500, "DB Error")
    end
    
    return http_server.response_json("{\"status\": \"deleted\"}")
end

// ============================================
// Router & Main
// ============================================

func router(req: http_parser.HttpRequest) -> http_parser.HttpResponse
    print(fmt("%s %s", req.method, req.path))
    
    if req.method == "GET" && req.path == "/api/passwords" then
        return handle_list_passwords()
    end
    
    if req.method == "POST" && req.path == "/api/passwords" then
        return handle_save_password(req.body)
    end
    
    if req.method == "DELETE" && strings.starts_with(req.path, "/api/passwords/") then
        let id_part: string = strings.substring(req.path, 15, length(req.path))
        return handle_delete_password(id_part)
    end
    
    if req.method == "GET" then
        if req.path == "/" || req.path == "/index.html" then
            return http_server.response_html(read_file("public/index.html"))
        end
        if req.path == "/style.css" then
            return http_server.response_ok(to_bytes(read_file("public/style.css")), "text/css")
        end
        if req.path == "/script.js" then
            return http_server.response_ok(to_bytes(read_file("public/script.js")), "application/javascript")
        end
    end
    
    return http_server.response_404()
end

let host: string = "127.0.0.1"
let port: int = 9000

// ============================================
// Inicialização da Senha Mestra
// ============================================
print("")
print("=== Password Manager com AES-256-GCM ===")
print("")
let master_password: string = input("Digite a senha mestra: ")

if strings.is_empty(master_password) then
    print("Erro: Senha mestra não pode ser vazia.")
    return
end

print("Derivando chave (pode levar alguns segundos)...")
if !init_master_key(master_password) then
    print("Erro ao inicializar chave mestra.")
    return
end
print("Chave mestra derivada com sucesso!")
print("")

let server: http_server.HttpServer = http_server.new_server(host, port)

print(fmt("Password Manager running at http://%s:%d", host, port))
http_server.serve(server, router)
