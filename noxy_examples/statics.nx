
struct Statics
    data: int[]
    mean: float
    median: float
    mode: int[]
    std_dev: float
end

func sqrt(x: float) -> float
    if x < 0.0 then return 0.0 end
    if x == 0.0 then return 0.0 end
    let z: float = x
    let i: int = 0
    // Newton-Raphson method
    while i < 20 do
        z = (z + x / z) / 2.0
        i = i + 1
    end
    return z
end

func sort(data: int[]) -> int[]
    // quicksort
    if length(data) <= 1 then
        return data
    end
    
    let pivot_idx: int = length(data) / 2
    let pivot: int = data[pivot_idx]
    
    let left: int[] = []
    let right: int[] = []
    let equal: int[] = []
    
    let i: int = 0
    while i < length(data) do
        if data[i] < pivot then
            append(left, data[i])
        elif data[i] > pivot then
            append(right, data[i])
        else
            append(equal, data[i])
        end
        i = i + 1
    end
    
    let sorted_left: int[] = sort(left)
    let sorted_right: int[] = sort(right)
    
    // Merge: sorted_left + equal + sorted_right
    let res: int[] = sorted_left
    
    let j: int = 0
    while j < length(equal) do
        append(res, equal[j])
        j = j + 1
    end
    
    let k: int = 0
    while k < length(sorted_right) do
        append(res, sorted_right[k])
        k = k + 1
    end
    
    return res
end

func calculate_mean(data: int[]) -> float
    if length(data) == 0 then return 0.0 end
    let sum: float = 0.0
    let i: int = 0
    while i < length(data) do
        sum = sum + to_float(data[i])
        i = i + 1
    end
    return sum / to_float(length(data))
end

func calculate_median(data: int[]) -> float
    if length(data) == 0 then return 0.0 end
    let sorted_data: int[] = sort(data)
    let mid: int = length(sorted_data) / 2
    
    if length(sorted_data) % 2 == 0 then
        return (to_float(sorted_data[mid - 1]) + to_float(sorted_data[mid])) / 2.0
    else
        return to_float(sorted_data[mid])
    end
end

func calculate_mode(data: int[]) -> int[]
    let counts: map[int, int] = {}
    let i: int = 0
    while i < length(data) do
        let key: int = data[i]
        if has_key(counts, key) then
            counts[key] = counts[key] + 1
        else
            counts[key] = 1
        end
        i = i + 1
    end
    
    let max_count: int = 0
    for key in counts do
        if counts[key] > max_count then
            max_count = counts[key]
        end
    end
    
    let mode: int[] = []
    for key in counts do
        if counts[key] == max_count then
            append(mode, key)
        end
    end
    
    // Sort to ensure deterministic output (map iteration is random)
    return sort(mode)
end

func calculate_std_dev(data: int[]) -> float
    if length(data) == 0 then return 0.0 end
    let mean: float = calculate_mean(data)
    
    let sum_sq_diff: float = 0.0
    let i: int = 0
    while i < length(data) do
        let diff: float = to_float(data[i]) - mean
        sum_sq_diff = sum_sq_diff + diff * diff
        i = i + 1
    end
    return sqrt(sum_sq_diff / to_float(length(data)))
end

func calculate_statics(data: int[]) -> Statics
    let _statics: Statics = Statics(data, 0.0, 0.0, [], 0.0)
    _statics.mean = calculate_mean(data)
    _statics.median = calculate_median(data)
    _statics.mode = calculate_mode(data)
    _statics.std_dev = calculate_std_dev(data)
    return _statics
end

// "Constructor" pattern: NewStatics
// Returns a reference (pointer) to a new Statics object.
// In Noxy, returning 'ref local_var' is safe (promoted to Heap).
func new_statics(data: int[]) -> ref Statics
    // Create struct value
    let s: Statics = Statics(data, 0.0, 0.0, [], 0.0)
    
    // Return reference to it.
    // Equivalent to Go's: return &Statics{...}
    return ref s
end

// "Method" employing pointer/reference semantics
func compute(s: ref Statics) -> void
    // Access fields directly via reference (auto-dereference)
    // Note: In Noxy, s.data works even if s is a reference.
    // Assignments to s.mean also update the original struct.
    
    s.mean = calculate_mean(s.data)
    s.median = calculate_median(s.data)
    s.mode = calculate_mode(s.data)
    s.std_dev = calculate_std_dev(s.data)
end