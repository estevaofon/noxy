// ============================================
// PARSER JSON EM NOXY (com AST)
// ============================================

print("=== PARSER JSON EM NOXY (AST) ===")
print("")

// ============================================
// TIPOS DE TOKEN
// ============================================

let TOKEN_LBRACKET: int = 1     // [
let TOKEN_RBRACKET: int = 2     // ]
let TOKEN_LBRACE: int = 3       // {
let TOKEN_RBRACE: int = 4       // }
let TOKEN_COLON: int = 5        // :
let TOKEN_COMMA: int = 6        // ,
let TOKEN_STRING: int = 7       // "string"
let TOKEN_NUMBER: int = 8       // 123 ou 123.456
let TOKEN_TRUE: int = 9         // true
let TOKEN_FALSE: int = 10       // false
let TOKEN_NULL: int = 11        // null
let TOKEN_EOF: int = 12         // fim do arquivo

// ============================================
// ESTRUTURAS DE DADOS
// ============================================

struct Token
    tipo: int,
    valor: string,
    numero: float,
    posicao: int
end

// Nó da AST
struct JSONValue
    tipo: int,           // 1=string, 2=number, 3=bool, 4=null, 5=array, 6=object
    str_value: string,
    num_value: float,
    bool_value: bool,
    filhos: [JSONValue],
    chaves: [string]
end

// ============================================
// VARIÁVEIS GLOBAIS
// ============================================

global parser_cursor: int = 0
global parser_texto: string = ""
global parser_tamanho: int = 0
global lookahead_tipo: int = 0
global lookahead_valor: string = ""
global lookahead_numero: float = 0.0
global lookahead_posicao: int = 0
global parser_erro: bool = false
global parser_mensagem: string = ""

// ============================================
// TOKENIZER
// ============================================

func inicializar_tokenizer(texto: string) -> void
    parser_cursor = 0
    parser_texto = texto
    parser_tamanho = strlen(texto)
    parser_erro = false
    parser_mensagem = ""
end

func pular_espacos() -> void
    while parser_cursor < parser_tamanho do
        let c: string = parser_texto[parser_cursor]
        if (c != " ") & (c != "\t") & (c != "\n") & (c != "\r") then
            return
        end
        parser_cursor = parser_cursor + 1
    end
end

func eh_digito(c: string) -> bool
    let code: int = ord(c)
    return (code >= 48) & (code <= 57)
end

func ler_string() -> string
    let resultado: string = ""
    parser_cursor = parser_cursor + 1
    while parser_cursor < parser_tamanho do
        let c: string = parser_texto[parser_cursor]
        if c == "\"" then
            parser_cursor = parser_cursor + 1
            return resultado
        end
        if c == "\\" then
            parser_cursor = parser_cursor + 1
            if parser_cursor < parser_tamanho then
                let next: string = parser_texto[parser_cursor]
                if next == "n" then resultado = resultado + "\n"
                else if next == "t" then resultado = resultado + "\t"
                else if next == "\"" then resultado = resultado + "\""
                else resultado = resultado + next
            end
        else
            resultado = resultado + c
        end
        parser_cursor = parser_cursor + 1
    end
    return resultado
end

func ler_numero() -> float
    let resultado: float = 0.0
    let tem_ponto: bool = false
    let divisor: float = 10.0
    let eh_negativo: bool = false
    if parser_texto[parser_cursor] == "-" then
        eh_negativo = true
        parser_cursor = parser_cursor + 1
    end
    while parser_cursor < parser_tamanho do
        let c: string = parser_texto[parser_cursor]
        if eh_digito(c) then
            let digito: float = to_float(ord(c) - 48)
            if tem_ponto then
                resultado = resultado + (digito / divisor)
                divisor = divisor * 10.0
            else
                resultado = resultado * 10.0 + digito
            end
            parser_cursor = parser_cursor + 1
        else if c == "." then
            if !tem_ponto then
                tem_ponto = true
                parser_cursor = parser_cursor + 1
            else break
        else break
    end
    if eh_negativo then resultado = 0.0 - resultado end
    return resultado
end

func verificar_literal(literal: string) -> bool
    let len: int = strlen(literal)
    let i: int = 0
    let pos_salva: int = parser_cursor
    while i < len do
        if parser_cursor >= parser_tamanho then
            parser_cursor = pos_salva
            return false
        end
        if parser_texto[parser_cursor] != literal[i] then
            parser_cursor = pos_salva
            return false
        end
        parser_cursor = parser_cursor + 1
        i = i + 1
    end
    return true
end

func proximo_token() -> void
    pular_espacos()
    if parser_cursor >= parser_tamanho then
        lookahead_tipo = TOKEN_EOF
        lookahead_valor = ""
        lookahead_numero = 0.0
        lookahead_posicao = parser_cursor
        return
    end
    let c: string = parser_texto[parser_cursor]
    lookahead_posicao = parser_cursor
    if c == "[" then parser_cursor = parser_cursor + 1; lookahead_tipo = TOKEN_LBRACKET; return end
    if c == "]" then parser_cursor = parser_cursor + 1; lookahead_tipo = TOKEN_RBRACKET; return end
    if c == "{" then parser_cursor = parser_cursor + 1; lookahead_tipo = TOKEN_LBRACE; return end
    if c == "}" then parser_cursor = parser_cursor + 1; lookahead_tipo = TOKEN_RBRACE; return end
    if c == ":" then parser_cursor = parser_cursor + 1; lookahead_tipo = TOKEN_COLON; return end
    if c == "," then parser_cursor = parser_cursor + 1; lookahead_tipo = TOKEN_COMMA; return end
    if c == "\"" then lookahead_valor = ler_string(); lookahead_tipo = TOKEN_STRING; return end
    if eh_digito(c) | (c == "-") then lookahead_numero = ler_numero(); lookahead_tipo = TOKEN_NUMBER; return end
    if verificar_literal("true") then lookahead_tipo = TOKEN_TRUE; return end
    if verificar_literal("false") then lookahead_tipo = TOKEN_FALSE; return end
    if verificar_literal("null") then lookahead_tipo = TOKEN_NULL; return end
    parser_erro = true
    parser_mensagem = "Caractere não reconhecido: " + c
    lookahead_tipo = TOKEN_EOF
end

// ============================================
// PARSER
// ============================================

func consumir(tipo_esperado: int) -> bool
    if lookahead_tipo != tipo_esperado then
        parser_erro = true
        parser_mensagem = "Token inesperado na posição " + to_str(lookahead_posicao)
        return false
    end
    proximo_token()
    return true
end

func parse_valor() -> JSONValue
    if lookahead_tipo == TOKEN_STRING then
        let v: string = lookahead_valor
        consumir(TOKEN_STRING)
        return JSONValue(1, v, 0.0, false, [], [])
    end
    if lookahead_tipo == TOKEN_NUMBER then
        let n: float = lookahead_numero
        consumir(TOKEN_NUMBER)
        return JSONValue(2, "", n, false, [], [])
    end
    if lookahead_tipo == TOKEN_TRUE then
        consumir(TOKEN_TRUE)
        return JSONValue(3, "", 0.0, true, [], [])
    end
    if lookahead_tipo == TOKEN_FALSE then
        consumir(TOKEN_FALSE)
        return JSONValue(3, "", 0.0, false, [], [])
    end
    if lookahead_tipo == TOKEN_NULL then
        consumir(TOKEN_NULL)
        return JSONValue(4, "", 0.0, false, [], [])
    end
    if lookahead_tipo == TOKEN_LBRACKET then
        return parse_array()
    end
    if lookahead_tipo == TOKEN_LBRACE then
        return parse_objeto()
    end
    parser_erro = true
    parser_mensagem = "Valor JSON inválido"
    return JSONValue(0, "ERRO", 0.0, false, [], [])
end

func parse_array() -> JSONValue
    consumir(TOKEN_LBRACKET)
    let elementos: [JSONValue] = []
    if lookahead_tipo == TOKEN_RBRACKET then
        consumir(TOKEN_RBRACKET)
        return JSONValue(5, "[]", 0.0, false, elementos, [])
    end
    while (lookahead_tipo != TOKEN_RBRACKET) & (!parser_erro) do
        let elem: JSONValue = parse_valor()
        push(elementos, elem)
        if lookahead_tipo == TOKEN_COMMA then consumir(TOKEN_COMMA)
        else if lookahead_tipo != TOKEN_RBRACKET then
            parser_erro = true
            parser_mensagem = "Esperado ',' ou ']' no array"
            return JSONValue(0, "ERRO", 0.0, false, [], [])
        end
    end
    consumir(TOKEN_RBRACKET)
    return JSONValue(5, "[array]", to_float(len(elementos)), false, elementos, [])
end

func parse_objeto() -> JSONValue
    consumir(TOKEN_LBRACE)
    let props: [JSONValue] = []
    let chaves: [string] = []
    if lookahead_tipo == TOKEN_RBRACE then
        consumir(TOKEN_RBRACE)
        return JSONValue(6, "{}", 0.0, false, props, chaves)
    end
    while (lookahead_tipo != TOKEN_RBRACE) & (!parser_erro) do
        if lookahead_tipo != TOKEN_STRING then
            parser_erro = true
            parser_mensagem = "Esperada string como chave"
            return JSONValue(0, "ERRO", 0.0, false, [], [])
        end
        let chave: string = lookahead_valor
        consumir(TOKEN_STRING)
        consumir(TOKEN_COLON)
        let valor: JSONValue = parse_valor()
        push(props, valor)
        push(chaves, chave)
        if lookahead_tipo == TOKEN_COMMA then consumir(TOKEN_COMMA)
        else if lookahead_tipo != TOKEN_RBRACE then
            parser_erro = true
            parser_mensagem = "Esperado ',' ou '}' no objeto"
            return JSONValue(0, "ERRO", 0.0, false, [], [])
        end
    end
    consumir(TOKEN_RBRACE)
    return JSONValue(6, "{objeto}", to_float(len(props)), false, props, chaves)
end

func parse_json(texto: string) -> JSONValue
    inicializar_tokenizer(texto)
    proximo_token()
    return parse_valor()
end

func tipo_para_string(tipo: int) -> string
    if tipo == 1 then return "STRING" end
    if tipo == 2 then return "NUMBER" end
    if tipo == 3 then return "BOOL" end
    if tipo == 4 then return "NULL" end
    if tipo == 5 then return "ARRAY" end
    if tipo == 6 then return "OBJECT" end
    return "DESCONHECIDO"
end

// ============================================
// IMPRESSÃO DA AST
// ============================================

func imprimir_ast(node: JSONValue, nivel: int) -> void
    let indent: string = ""
    let i: int = 0
    while i < nivel do
        indent = indent + "  "
        i = i + 1
    end
    print(indent + "- " + tipo_para_string(node.tipo))
    if node.tipo == 1 then print(indent + "  valor: \"" + node.str_value + "\"") end
    if node.tipo == 2 then print(indent + "  valor: " + to_str(node.num_value)) end
    if node.tipo == 3 then print(indent + "  valor: " + to_str(node.bool_value)) end
    if node.tipo == 4 then print(indent + "  valor: null") end
    if node.tipo == 5 then
        let j: int = 0
        while j < len(node.filhos) do
            imprimir_ast(node.filhos[j], nivel + 1)
            j = j + 1
        end
    end
    if node.tipo == 6 then
        let j: int = 0
        while j < len(node.filhos) do
            print(indent + "  chave: " + node.chaves[j])
            imprimir_ast(node.filhos[j], nivel + 1)
            j = j + 1
        end
    end
end

// ============================================
// TESTES
// ============================================

let json1: string = "{\"nome\": \"Ana\", \"notas\": [8, 9, 10], \"ativo\": true}"
let ast1: JSONValue = parse_json(json1)

print("Input: " + json1)
if parser_erro then
    print("ERRO: " + parser_mensagem)
else
    print("AST:")
    imprimir_ast(ast1, 0)
end

let json2: string = "[{\"id\":1}, {\"id\":2}]"
let ast2: JSONValue = parse_json(json2)

print("")
print("Input: " + json2)
if parser_erro then
    print("ERRO: " + parser_mensagem)
else
    print("AST:")
    imprimir_ast(ast2, 0)
end

print("")
print("=== PARSER JSON (AST) CONCLUÍDO ===")
