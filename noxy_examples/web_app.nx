

// ============================================
// NOXY WEB APP - API REST
// ============================================



// ============================================
// HTTP Response Struct
// ============================================

struct Response
    status: int
    content_type: string
    body: string
end

// Helper functions para criar responses
func json_response(status: int, body: string) -> Response
    return Response(status, "application/json", body)
end

func error_response(status: int, message: string) -> Response
    let body: string = "{\"error\": \"" + message + "\"}"
    return Response(status, "application/json", body)
end

// ============================================
// Modelo de Dados - User (Lista Encadeada)
// ============================================

struct User
    id: int
    name: string
    age: int
    next: ref User
end

// Armazenamento em memória (lista encadeada)
global users_head: ref User = null
global user_count: int = 0

// ============================================
// Controllers - Retornam Response
// ============================================


struct UserRequest
    name: string
    age: int
end

func handle_users_post(requestBody: ref UserRequest) -> Response
    let name: string = requestBody.name
    let age: int = requestBody.age
    
    if (strlen(name) == 0) | (age == 0) then
        return error_response(400, "Campos 'name' e 'age' obrigatorios")
    end
    
    // Cria novo usuário e insere no início da lista
    let new_id: int = user_count + 1
    let new_user: ref User = User(new_id, name, age, users_head)
    users_head = new_user
    user_count = user_count + 1
    
    print(f"LOG: Usuario criado - ID={new_id}, name={name}, age={age}")
    
    let resp: map = {"status": "created", "id": new_id, "link": "/users/" + to_str(new_id)}
    return json_response(201, json_dumps(resp))
end

func handle_users_get() -> Response
    // Monta JSON array manual pois lista encadeada não é facilmente serializavel direto
    // A menos que convertamos para array primeiro.
    
    let result: string = "["
    let current: ref User = users_head
    let first: int = 1
    while current != null do
        if first == 0 then
            result = result + ", "
        end
        first = 0
        // Use manual construction or struct map
        let item: map = {"id": current.id, "name": current.name, "age": current.age}
        result = result + json_dumps(item)
        current = current.next
    end
    result = result + "]"
    
    return json_response(200, result)
end

// ============================================
// Router Principal
// ============================================


struct WebRequest
    method: string
    path: string
    body: UserRequest // Targeted for users post. generic body handling is complex without `any` map support in struct fields fully
end

func handle_request(raw_json: string) -> Response
    print(f"Servidor recebeu raw: {raw_json}")
    
    // Parse generic map first to get method/path? 
    // Or just partial decode? The example structure suggests the outer wrapper is a request object?
    // It seems the "web app" receives a JSON payload representing the HTTP request? Unusual but ok.
    
    // Let's use generic parsing for the root object since `body` can be diverse.
    let root: map = json_parse(raw_json)
    if root == null then return error_response(400, "Invalid JSON Request") end
    
    let method: string = root["method"]
    let path: string = root["path"]
    
    // Note: accessing "body" from map returns a generic value (likely map or null)
    let body_map: any = root["body"]
    
    print(f"Processando: {method} {path}")
    
    // Roteamento
    if path == "/users" then
        if method == "POST" then
            if body_map == null then
                return error_response(400, "Body ausente")
            else
                // Convert body map to UserRequest struct or pass map?
                // For safety let's re-encode and decode to struct or just manually extract
                // Or update handle_users_post to take map. Let's update handle_users_post to take struct
                // and populate it here.
                
                // Simulating json_loads behavior for nested object:
                // ideally: json_loads(json_dumps(body_map), ref req)
                // But that's inefficient.
                // Let's just manually extract from map for this example as it is simple.
                // Wait, handle_users_post expects UserRequest.
                
                let req: UserRequest = UserRequest("", 0)
                // Use the map directly if possible? No.
                // Let's populate manually:
                let m: map = body_map // Cast
                if has_key(m, "name") then req.name = m["name"] end
                if has_key(m, "age") then req.age = to_int(m["age"]) end

                return handle_users_post(ref req)
            end
        else
            if method == "GET" then
                return handle_users_get()
            else
                return error_response(405, "Method Not Allowed")
            end
        end
    else
        return error_response(404, "Endpoint nao encontrado")
    end
end
