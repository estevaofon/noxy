// ============================================
// JSON LEXER EM NOXY (AJUSTADO COM STRINGS)
// ============================================

// Inicializar constantes dos tipos de tokens
let TOKEN_LBRACKET: int = 1 // [
let TOKEN_RBRACKET: int = 2 // ]
let TOKEN_LBRACE: int = 3 // {
let TOKEN_RBRACE: int = 4 // }
let TOKEN_COLON: int = 5 // :
let TOKEN_COMMA: int = 6 // ,
let TOKEN_STRING: int = 7 // "string"
let TOKEN_NUMBER: int = 8 // 123 ou 123.456
let TOKEN_TRUE: int = 9 // true
let TOKEN_FALSE: int = 10 // false
let TOKEN_NULL: int = 11 // null
let TOKEN_EOF: int = 12 // EOF

// Estrutura do token
struct Token
    type: int,
    value: string,
    position: int
end

struct OptionalString
    value: string,
    is_some: bool
end

// Inicializar array de tokens com tokens vazios em vez de null
let tokens: Token[16] = [Token(0, "", 0), Token(0, "", 0), Token(0, "", 0), Token(0, "", 0), Token(0, "", 0), Token(0, "", 0), Token(0, "", 0), Token(0, "", 0), Token(0, "", 0), Token(0, "", 0), Token(0, "", 0), Token(0, "", 0), Token(0, "", 0), Token(0, "", 0), Token(0, "", 0), Token(0, "", 0)]

struct Lexer
    source: string,
    position: int,
    tokens: Token[16]
end

func source_length(lexer: Lexer) -> int
    let raw_source: string = lexer.source
    let length: int = 0
    while raw_source[length] != 0 do
        length = length + 1
    end
    return length
end

func current_char(lexer: Lexer) -> OptionalString
    if lexer.position >= source_length(lexer) then
        return OptionalString("", false)
    end
    let char_local: string = lexer.source
    return OptionalString(char_local[lexer.position], true)
end

func advance(lexer: Lexer) 
    lexer.position = lexer.position + 1
end 

func skip_whitespace(lexer: Lexer)
    let char: OptionalString = current_char(lexer)
    let is_true: bool = char.is_some & (char.value == " " | char.value == "\t" | char.value == "\n" | char.value == "\r")
    while is_true do
        advance(lexer)
        char = current_char(lexer)
        is_true = char.is_some & (char.value == " " | char.value == "\t" | char.value == "\n" | char.value == "\r")
    end
end

func isalnum(ch: string) -> bool
    return (ch >= "a" & ch <= "z") | (ch >= "A" & ch <= "Z") | (ch >= "0" & ch <= "9")
end

func read_identifier(lexer: Lexer) -> string
    let char: OptionalString = current_char(lexer)
    let identifier: string = ""
    let is_true: bool = char.is_some & isalnum(char.value)
    while is_true do
        identifier = identifier + char.value
        advance(lexer)
        char = current_char(lexer)
        is_true = char.is_some & isalnum(char.value)
    end
    return identifier
end

// ===== NOVA FUNÇÃO PARA LER STRINGS =====
func read_string(lexer: Lexer) -> string
    // pular a aspa inicial
    advance(lexer)
    let result: string = ""
    let char: OptionalString = current_char(lexer)
    let is_true: bool = char.is_some & (char.value != "\"")
    while is_true do
        result = result + char.value
        advance(lexer)
        char = current_char(lexer)
        is_true = char.is_some & (char.value != "\"")
    end
    // pular a aspa final
    if char.is_some & char.value == "\"" then
        advance(lexer)
    end
    return result
end

func tokenize(lexer: Lexer) -> Token[]
    let i: int = 0
    let size: int = source_length(lexer)
    while lexer.position < size do
        skip_whitespace(lexer)
        let char: OptionalString = current_char(lexer)
        if !char.is_some then
            break
        end

        if char.value == "{" then
            tokens[i] = Token(TOKEN_LBRACE, char.value, lexer.position)
            advance(lexer)
        end
        if char.value == "}" then
            tokens[i] = Token(TOKEN_RBRACE, char.value, lexer.position)
            advance(lexer)
        end
        if char.value == "[" then
            tokens[i] = Token(TOKEN_LBRACKET, char.value, lexer.position)
            advance(lexer)
        end
        if char.value == "]" then
            tokens[i] = Token(TOKEN_RBRACKET, char.value, lexer.position)
            advance(lexer)
        end
        if char.value == ":" then
            tokens[i] = Token(TOKEN_COLON, char.value, lexer.position)
            advance(lexer)
        end
        if char.value == "," then
            tokens[i] = Token(TOKEN_COMMA, char.value, lexer.position)
            advance(lexer)
        end
        if char.value == "\"" then
            let string_value: string = read_string(lexer)
            tokens[i] = Token(TOKEN_STRING, string_value, lexer.position)
        end
        if char.value == "-" | char.value == "0" | char.value == "1" | char.value == "2" | char.value == "3" | char.value == "4" | char.value == "5" | char.value == "6" | char.value == "7" | char.value == "8" | char.value == "9" then
            tokens[i] = Token(TOKEN_NUMBER, char.value, lexer.position)
            advance(lexer)
        end
        if isalnum(char.value) then
            let identifier: string = read_identifier(lexer)
            tokens[i] = Token(TOKEN_STRING, identifier, lexer.position)
        end
        i = i + 1
    end
    return tokens
end

func token_type_name(t: int) -> string
    if t == TOKEN_LBRACKET then return "LBRACKET" end
    if t == TOKEN_RBRACKET then return "RBRACKET" end
    if t == TOKEN_LBRACE then return "LBRACE" end
    if t == TOKEN_RBRACE then return "RBRACE" end
    if t == TOKEN_COLON then return "COLON" end
    if t == TOKEN_COMMA then return "COMMA" end
    if t == TOKEN_STRING then return "STRING" end
    if t == TOKEN_NUMBER then return "NUMBER" end
    if t == TOKEN_TRUE then return "TRUE" end
    if t == TOKEN_FALSE then return "FALSE" end
    if t == TOKEN_NULL then return "NULL" end
    if t == TOKEN_EOF then return "EOF" end
    return "UNKNOWN"
end

let json_string: string = "{\"name\": \"John\", \"city\": \"New York\"}"
let lexer: Lexer = Lexer(json_string, 0, tokens)
let tokens_result: Token[16] = tokenize(lexer)

// print tokens de forma legível
let i: int = 0
while i < 16 do
    if tokens_result[i].type != 0 then
        print("[" + token_type_name(tokens_result[i].type) + "] " + tokens_result[i].value)
    end
    i = i + 1
end