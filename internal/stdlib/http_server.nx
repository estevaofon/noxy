// stdlib/http_server.nx - Servidor HTTP Event-Driven

use net select *
use io select *
use http_parser select *

// ============================================
// Estruturas
// ============================================

struct HttpServer
    host: string,             // "0.0.0.0"
    port: int,                // 8080
    server_socket: Socket,    // Socket do listener
    running: bool,            // Flag de controle
    client_sockets: Socket[64], // Array de clientes conectados
    handler: int              // Placeholder
end

struct RequestEvent
    type: string,             // "REQUEST", "NONE", "ERROR"
    client_index: int,        // ?ndice do cliente no array
    request: HttpRequest
end

// ============================================
// Factory & Lifecycle
// ============================================

func new_server(host: string, port: int) -> HttpServer
    // Cria servidor com socket inv?lido inicial
    // Cria servidor com socket inv?lido inicial
    // Socket() cria um inv?lido por padr?o (fd=-1)
    let s: Socket = Socket(-1, "", 0, false) 
    let sockets: Socket[64]
    
    return HttpServer(host, port, s, false, sockets, 0)
end

func start(server: ref HttpServer) -> bool
    let s: Socket = listen(server.host, server.port)
    if !s.open then
        return false
    end
    
    server.server_socket = s
    setblocking(s, false) // Non-blocking accept
    server.running = true
    
    // Inicializa slots de clientes ? J? s?o Socket() inv?lidos
    return true
end

func stop(server: ref HttpServer) -> void
    server.running = false
    net_close(server.server_socket)
    
    let i: int = 0
    while i < 64 do
        if server.client_sockets[i] != null then
            if server.client_sockets[i].open then
                net_close(server.client_sockets[i])
            end
        end
        i = i + 1
    end
end

// ============================================
// Event Loop
// ============================================

func server_poll(server: ref HttpServer) -> RequestEvent
    // Evento padr?o (None)
    let empty_headers: string[64]
    let no_event: RequestEvent = RequestEvent("NONE", -1, HttpRequest("GET", "/", "", "HTTP/1.1", empty_headers, 0, b""))
    
    // Arrays para select
    let inputs: Socket[64]
    let outputs: Socket[64]
    let errors: Socket[64]
    
    // 1. Preparar lista de inputs
    inputs[0] = server.server_socket
    let input_count: int = 1
    
    let i: int = 0
    while i < 64 do
        if server.client_sockets[i] != null then
            if server.client_sockets[i].open then
                if input_count < 64 then
                    inputs[input_count] = server.client_sockets[i]
                    input_count = input_count + 1
                end
            end
        end
        i = i + 1
    end
    
    // 2. Poll (timeout 50ms)
    // 2. Poll (timeout 50ms)
    let res: SelectResult = poll(inputs, outputs, errors, 50)
    
    if res.read_count > 0 then
        let j: int = 0
        while j < res.read_count do
            let active_sock: Socket = res.read[j]
            
            // Verifica se ? o listener
            let is_listener: bool = false
            if active_sock == server.server_socket then
                is_listener = true
            end
            
            if is_listener then
                // Accept new connection
                let client: Socket = accept(server.server_socket)
                if client.open then
                    setblocking(client, false)
                    
                    // Add to slots
                    let added: bool = false
                    let k: int = 0
                    while k < 64 do
                        // Find empty slot (null or closed)
                        let slot_free: bool = false
                        if server.client_sockets[k] == null then
                            slot_free = true
                        else
                            if !server.client_sockets[k].open then
                                slot_free = true
                            end
                        end
                        
                        if slot_free then
                            server.client_sockets[k] = client
                            added = true
                            break
                        end
                        k = k + 1
                    end
                    
                    if !added then
                        print("Server full")
                        net_close(client)
                    end
                end
                // Continue loop processing other sockets? 
                // For simplicity, we process one event per poll or just minimal internal work
            else
                // Read from client
                let recv_res: NetResult = recv(active_sock, 16384)
                
                // Identify client index
                let client_idx: int = -1
                let k: int = 0
                while k < 64 do
                    if server.client_sockets[k] == active_sock then
                        client_idx = k
                        break
                    end
                    k = k + 1
                end
                
                if !recv_res.ok || (recv_res.count == 0) then
                    // Closed
                    net_close(active_sock)
                    if client_idx != -1 then
                        server.client_sockets[client_idx] = Socket(-1, "", 0, false)
                    end
                else
                    // Data received -> Parse Request
                    if client_idx != -1 then
                        let req: HttpRequest = parse_request(recv_res.data, recv_res.count)
                        return RequestEvent("REQUEST", client_idx, req)
                    end
                end
            end
            
            j = j + 1
        end
    end
    
    return no_event
end

func server_send(server: ref HttpServer, client_index: int, resp: HttpResponse) -> void
    if (client_index >= 0) && (client_index < 64) then
        let sock: Socket = server.client_sockets[client_index]
        if sock != null then
            if sock.open then
                let resp_bytes: bytes = build_response(resp.status_code, resp.status_text, resp.headers, resp.header_count, resp.body)
                send(sock, resp_bytes)
                
                // Close after send (HTTP 1.0 style for MVP)
                net_close(sock)
                // server.client_sockets[client_index] = Socket(-1, "", 0, false)
                // Can set to null instead? Or bad socket.
                server.client_sockets[client_index] = null
            end
        end
    end
end

// ============================================
// Response Helpers
// ============================================

func response_ok(body: bytes, content_type: string) -> HttpResponse
    let headers: string[64]
    headers[0] = "Content-Type: " + content_type
    headers[1] = "Content-Length: " + to_str(length(body))
    
    return HttpResponse("HTTP/1.1", 200, "OK", headers, 2, body)
end

func response_error(status_code: int, message: string) -> HttpResponse
    let body: bytes = to_bytes(message)
    let headers: string[64]
    headers[0] = "Content-Type: text/plain"
    headers[1] = "Content-Length: " + to_str(length(body))
    
    return HttpResponse("HTTP/1.1", status_code, get_status_text(status_code), headers, 2, body)
end

func response_json(data: string) -> HttpResponse
    return response_ok(to_bytes(data), "application/json")
end

func response_html(html: string) -> HttpResponse
    return response_ok(to_bytes(html), "text/html")
end

// ============================================
// Static Files
// ============================================

func serve_file(filepath: string) -> HttpResponse
    // Verifica exist?ncia
    // Assumindo io.exists dispon?vel (se n?o for, open falha)
    // Vamos tentar abrir direto
    
    let f: File = open(filepath, "r")
    // Como verificar se abriu? File tem 'open' ou similar?
    // io.nx geralmente retorna File struct. Se falha, pode dar erro ou retornar file inv?lido.
    // Vamos assumir que temos como checar ou usar try-catch se Noxy tivesse... 
    // Spec do IO diz que open retorna File. File tem handle?
    // Vamos assumir que open lan?a erro ou retorna algo chec?vel.
    // Baseado na spec anterior do IO: File tem descriptor?
    
    // Simplifica??o: vamos ler. Se der erro de leitura, return 500/404.
    // io.read retorna IOResult?
    // io.nx original: 
    // func read(f: File) -> IOResult
    
    let res: IOResult = read(f)
    close(f)
    
    if !res.ok then
        return response_error(404, "File not found or unreadable")
    end
    
    let content: string = res.data
    // IOResult.data ? string. Precisamos de bytes para o body.
    // Arquivos bin?rios (imagens) lidos como string podem corromper se Noxy strings forem utf-8 strict.
    // O io.nx usa 'read_text' ou 'read_binary'?
    // stdlib/io.nx mostrava 'io_read' retornando string.
    // Se quisermos servir imagens, precisaria ser bytes.
    // MVP: serve como string convertida para bytes. Pode quebrar imagens.
    
    let body: bytes = to_bytes(content)
    
    // Detect Mime Type (simplificado por extens?o)
    let mime: string = "application/octet-stream"
    if contains(filepath, ".html") then mime = "text/html" end
    if contains(filepath, ".css") then mime = "text/css" end
    if contains(filepath, ".js") then mime = "application/javascript" end
    if contains(filepath, ".json") then mime = "application/json" end
    if contains(filepath, ".png") then mime = "image/png" end
    if contains(filepath, ".jpg") then mime = "image/jpeg" end
    
    let headers: string[64]
    headers[0] = "Content-Type: " + mime
    headers[1] = "Content-Length: " + to_str(length(body))
    
    return HttpResponse("HTTP/1.1", 200, "OK", headers, 2, body)
end

// Helper contains (usa strings.contains do m?dulo strings)
func contains(haystack: string, needle: string) -> bool
    return strings_contains(haystack, needle)
end
