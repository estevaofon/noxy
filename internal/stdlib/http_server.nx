// stdlib/http_server.nx - Concurrent HTTP Server
use net select *
use io select *
use strings select *
use http_parser select *

// ============================================
// Structure
// ============================================

struct HttpServer
    host: string
    port: int
    listener: Socket
    running: bool
end

// ============================================
// Factory
// ============================================

func new_server(host: string, port: int) -> HttpServer
    // Return with invalid socket initially
    let s: Socket = Socket(-1, "", 0, false)
    return HttpServer(host, port, s, false)
end

// ============================================
// Handler Internal Logic
// ============================================

// This function runs in a separate routine (spawned)
func handle_client_connection(client: Socket, user_handler: func)
    // 1. Read Request
    // Read request chunk. Note: A production implementation should read continuously until header end.
    // Blocking read is acceptable here as this runs in a separate routine.
    
    let res: NetResult = socket_recv(client, 65536) // 64KB buffer
    
    if !res.ok || res.count == 0 then
        socket_close(client)
        return
    end
    
    // 2. Parse
    let req: HttpRequest = parse_request(res.data, res.count)
    
    // 3. Call User Handler
    // Dispatch request to user handler. Handler must match expected signature.
    // Note: Exceptions in handler will terminate this routine.
    
    let response: HttpResponse = user_handler(req)
    
    // 4. Send Response
    let resp_bytes: bytes = build_response(response.status_code, response.status_text, response.headers, response.header_count, response.body)
    socket_send(client, resp_bytes)
    
    // 5. Close
    socket_close(client)
end

// ============================================
// Server Loop
// ============================================

func serve(server: ref HttpServer, handler: func) -> void
    // 1. Listen
    let s: Socket = listen(server.host, server.port)
    if !s.open then
        print("Failed to bind to " + server.host + ":" + to_str(server.port))
        return
    end
    
    server.listener = s
    server.running = true
    
    print("Server listening on " + server.host + ":" + to_str(server.port))
    
    // 2. Accept Loop
    while server.running do
        // Accept blocks until a connection arrives
        let client: Socket = accept(server.listener)
        
        if client.open then
            // Spawn a routine to handle this client
            spawn(handle_client_connection, client, handler)
        else
            // Accept failed (maybe server closed?)
            // Small sleep to avoid cpu spin if it's a transient fail
            // sleep(10)? 
        end
    end
    
    socket_close(server.listener)
end

func stop_server(server: ref HttpServer) -> void
    server.running = false
    socket_close(server.listener)
end

// ============================================
// Response Helpers (Exports)
// ============================================

func response_ok(body: bytes, content_type: string) -> HttpResponse
    let headers: string[64]
    headers[0] = "Content-Type: " + content_type
    headers[1] = "Content-Length: " + to_str(length(body))
    headers[2] = "Connection: close"
    
    return HttpResponse("HTTP/1.1", 200, "OK", headers, 3, body)
end

func response_text(text: string) -> HttpResponse
    return response_ok(to_bytes(text), "text/plain")
end

func response_json(json: string) -> HttpResponse
    return response_ok(to_bytes(json), "application/json")
end

func response_html(html: string) -> HttpResponse
    return response_ok(to_bytes(html), "text/html")
end

func response_error(status: int, msg: string) -> HttpResponse
    let headers: string[64]
    headers[0] = "Content-Type: text/plain"
    headers[1] = "Content-Length: " + to_str(length(msg))
    headers[2] = "Connection: close"
    
    return HttpResponse("HTTP/1.1", status, get_status_text(status), headers, 3, to_bytes(msg))
end

func response_404() -> HttpResponse
    return response_error(404, "Not Found")
end

func response_500() -> HttpResponse
    return response_error(500, "Internal Server Error")
end

// ============================================
// Static File Helper
// ============================================

func serve_static(path: string) -> HttpResponse
    // Basic security check (prevent directory traversal)
    if contains(path, "..") then
        return response_error(403, "Forbidden")
    end
    
    // Try open
    // Note: 'open' doesn't return error code in current IO spec, returns File.
    // We assume check existence or read fail.
    // Ideally use 'ok' check if available.
    
    let f: File = open(path, "r")
    let io_res: IOResult = read(f) // Reads all
    close(f) // File close is correct (io module)
    
    if !io_res.ok then
        return response_404()
    end
    
    let body: bytes = to_bytes(io_res.data)
    
    // Mime
    let mime: string = "application/octet-stream"
    if contains(path, ".html") then mime = "text/html" end
    if contains(path, ".css") then mime = "text/css" end
    if contains(path, ".js") then mime = "application/javascript" end
    if contains(path, ".json") then mime = "application/json" end
    if contains(path, ".png") then mime = "image/png" end
    if contains(path, ".jpg") then mime = "image/jpeg" end
    
    return response_ok(body, mime)
end