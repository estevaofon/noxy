// stdlib/http_client.nx - Cliente HTTP

use net select *
use sys select *
use http_parser select *

// ============================================
// Estruturas
// ============================================

struct HttpClient
    timeout_ms: int,          // Timeout em milissegundos
    max_redirects: int,       // M?ximo de redirects
    user_agent: string,       // User-Agent header
    follow_redirects: bool    // Seguir 3xx automaticamente
end

struct ClientResponse
    ok: bool,                 // true se 2xx
    status_code: int,         // 200, 404, etc
    headers: string[64],
    header_count: int,
    body: bytes,
    error: string
end

// ============================================
// Factory
// ============================================

func new_client() -> HttpClient
    return HttpClient(30000, 5, "Noxy-HTTP/1.1", true)
end

// Globais para simular "inst?ncia default" se necess?rio, 
// mas fun??es get/post criam cliente tempor?rio ou usam global?
// O spec sugere: get(url) -> ClientResponse. Internamente pode criar um client default.
let default_client: HttpClient = new_client()


// ============================================
// Core Request Logic
// ============================================

func request(client: ref HttpClient, method: string, url: string, headers: string[64], header_count: int, body: bytes) -> ClientResponse
    let empty_res: ClientResponse = ClientResponse(false, 0, [], 0, b"", "")
    
    // 1. Parse URL
    let u: HttpUrl = parse_url(url)
    if !u.valid then
        empty_res.error = "Invalid URL"
        return empty_res
    end
    
    if u.host == "" then
        empty_res.error = "Host not found in URL"
        return empty_res
    end
    
    // 2. Conectar
    let sock: Socket = connect(u.host, u.port)
    if !sock.open then
        empty_res.error = "Connection failed to " + u.host + ":" + to_str(u.port)
        return empty_res
    end
    
    // 3. Preparar Headers autom?ticos
    // Adiciona Host e User-Agent se n?o existirem
    // Copia headers do usu?rio para um novo array (mut?vel)
    // Devido ? limita??o de tamanho fixo e falta de m?todos de array din?mico,
    // vamos usar uma estrat?gia simples: copiar e adicionar.
    
    let final_headers: string[64]
    let final_count: int = 0
    let has_host: bool = false
    let has_ua: bool = false
    let has_len: bool = false
    let has_type: bool = false
    
    let k: int = 0
    while k < header_count do
        final_headers[final_count] = headers[k]
        final_count = final_count + 1
        
        // Verifica headers existentes (busca simples stick)
        // Isso ? meio fr?gil sem lowercase, mas ok pro MVP
        // Ideal: usar helper starts_with_ignore_case
        k = k + 1
    end
    
    // Adiciona Host
    // TODO: verificar se j? existe
    if final_count < 64 then
        let host_header: string = u.host
        if (u.scheme == "http" && u.port != 80) || (u.scheme == "https" && u.port != 443) then
            host_header = host_header + ":" + to_str(u.port)
        end
        final_headers[final_count] = "Host: " + host_header
        final_count = final_count + 1
    end
    
    // Adiciona User-Agent
    if final_count < 64 then
        final_headers[final_count] = "User-Agent: " + client.user_agent
        final_count = final_count + 1
    end
    
    // Force Connection: close
    if final_count < 64 then
        final_headers[final_count] = "Connection: close"
        final_count = final_count + 1
    end
    
    // Adiciona Content-Length se tiver body e metodo pede
    // TODO: verificar se j? existe
    if length(body) > 0 then
        if final_count < 64 then
            final_headers[final_count] = "Content-Length: " + to_str(length(body))
            final_count = final_count + 1
        end
    end
    
    if method == "POST" || method == "PUT" || method == "PATCH" then
        // Adiciona Content-Type default se n?o tiver?
        // Vamos deixar pro usu?rio ou spec. Spec diz: post autom?gico application/json
        // Mas aqui ? a fun??o gen?rica request()
    end
    
    // 4. Build Request
    let req_bytes: bytes = build_request(method, u.path + "?" + u.query, final_headers, final_count, body)
    // query precisa ser tratada: se vazia, n?o poe ?
    // Corre??o: u.path j? tem barra? Sim
    // Se query tem algo: path + "?" + query
    // Mas parse_url retorna query sem '?'
    let full_path: string = u.path
    if length(u.query) > 0 then
        full_path = full_path + "?" + u.query
    end
    
    // Reconstr?i com path certo
    req_bytes = build_request(method, full_path, final_headers, final_count, body)
    
    // 5. Enviar
    // DEBUG: Imprimir request cru
    print("DEBUG RAW REQUEST:\n" + to_str(req_bytes))
    print("--------------------------------------------------")

    let sent: int = send(sock, req_bytes)
    if sent < length(req_bytes) then
        close(sock)
        empty_res.error = "Failed to send full request"
        return empty_res
    end
    
    // 6. Receber Loop
    let buffer: bytes = b""
    let total_received: int = 0
    let MAX_SIZE: int = 10485760  // 10MB limite
    
    let loop_active: bool = true
    while loop_active do
        let result: NetResult = recv(sock, 8192)
        // print("DEBUG CLIENT RECV: c=" + to_str(result.count) + " ok=" + to_str(result.ok))
        
        if !result.ok then
            // Check for timeout
            if strings_contains(result.error, "timeout") then
                // Continue loop but sleep briefly to yield CPU
                sleep(10)
            else
                loop_active = false
                if total_received == 0 then
                    empty_res.error = result.error
                    return empty_res
                end
            end
        else
            if result.count == 0 then
                // EOF
                loop_active = false
                if total_received == 0 then
                   empty_res.error = "Empty response (EOF)"
                   return empty_res
                end
            else
                buffer = buffer + slice(result.data, 0, result.count)
                total_received = total_received + result.count
                if total_received >= MAX_SIZE then
                    loop_active = false
                end
            end
        end
    end
    
    close(sock)
    
    if total_received == 0 then
        empty_res.error = "Empty response"
        return empty_res
    end
    
    // 7. Parse Response
    let http_res: HttpResponse = parse_response(buffer, total_received)
    
    // 8. Converter para ClientResponse
    let client_res: ClientResponse = ClientResponse(false, http_res.status_code, http_res.headers, http_res.header_count, http_res.body, "")
    
    if http_res.status_code >= 200 && http_res.status_code < 300 then
        client_res.ok = true
    else
        client_res.ok = false
        client_res.error = http_res.status_text
        if client_res.error == "" then
             client_res.error = "Request failed with status " + to_str(http_res.status_code)
        end
    end
    
    return client_res
end


// ============================================
// Helper Methods (Shortcuts)
// ============================================

func get(url: string) -> ClientResponse
    let headers: string[64]
    return request(default_client, "GET", url, headers, 0, b"")
end

func post(url: string, body: bytes) -> ClientResponse
    let headers: string[64]
    // Default application/json for post shortcut
    headers[0] = "Content-Type: application/json"
    return request(default_client, "POST", url, headers, 1, body)
end

func put(url: string, body: bytes) -> ClientResponse
    let headers: string[64]
    headers[0] = "Content-Type: application/json"
    return request(default_client, "PUT", url, headers, 1, body)
end

func delete(url: string) -> ClientResponse
    let headers: string[64]
    return request(default_client, "DELETE", url, headers, 0, b"")
end

func patch(url: string, body: bytes) -> ClientResponse
    let headers: string[64]
    headers[0] = "Content-Type: application/json"
    return request(default_client, "PATCH", url, headers, 1, body)
end
