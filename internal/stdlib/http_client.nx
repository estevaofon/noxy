// stdlib/http_client.nx - Debug
use net select *
use strings select * 
use http_parser select *

struct HttpClient
    timeout_ms: int,
    user_agent: string
end

struct ClientResponse
    ok: bool,
    status_code: int,
    headers: string[64],
    header_count: int,
    body: bytes,
    error: string
end

func new_client() -> HttpClient
    return HttpClient(30000, "Noxy-HTTP/1.1")
end

let default_client: HttpClient = new_client()

func merge_headers(u: HttpUrl, method: string, user_headers: string[64], count: int, body_len: int, ua: string) -> string[64]
    let final: string[64]
    let idx: int = 0
    let i: int = 0
    while i < count do
        if idx < 64 then
            final[idx] = user_headers[i]
            idx = idx + 1
        end
        i = i + 1
    end
    let host_val: string = u.host
    if (u.scheme == "http" && u.port != 80) || (u.scheme == "https" && u.port != 443) then
        host_val = host_val + ":" + to_str(u.port)
    end
    if idx < 64 then
        final[idx] = "Host: " + host_val
        idx = idx + 1
    end
    if idx < 64 then
        final[idx] = "User-Agent: " + ua
        idx = idx + 1
    end
    if body_len > 0 then
        if idx < 64 then
            final[idx] = "Content-Length: " + to_str(body_len)
            idx = idx + 1
        end
    end
    if idx < 64 then
        final[idx] = "Accept: */*"
        idx = idx + 1
    end
    if idx < 64 then
        final[idx] = "Connection: close"
        idx = idx + 1
    end
    return final
end

func read_all(sock: Socket, timeout_ms: int) -> NetResult
    let buffer: bytes = b""
    let total: int = 0
    while true do
        let res: NetResult = socket_recv(sock, 8192)
        
        if !res.ok then
            return NetResult(false, buffer, total, res.error)
        end
        
        if res.count == 0 then
             break
        end
        
        buffer = buffer + slice(res.data, 0, res.count)
        total = total + res.count
    end
    return NetResult(true, buffer, total, "")
end

func request(client: ref HttpClient, method: string, url: string, headers: string[64], header_count: int, body: bytes) -> ClientResponse
    print("Debug: request start " + url)
    let empty_h: string[64]
    let empty_res: ClientResponse = ClientResponse(false, 0, empty_h, 0, b"", "")

    let u: HttpUrl = parse_url(url)
    if !u.valid then
        empty_res.error = "Invalid URL"
        return empty_res
    end
    
    let final_headers: string[64] = merge_headers(u, method, headers, header_count, length(body), client.user_agent)
    
    let path_with_query: string = u.path
    if length(u.query) > 0 then
        path_with_query = path_with_query + "?" + u.query
    end
    
    let final_count: int = 0
    while final_count < 64 do
        if final_headers[final_count] == "" then
            break
        end
        final_count = final_count + 1
    end
    
    let req_data: bytes = build_request(method, path_with_query, final_headers, final_count, body)
    
    let sock: Socket = connect(u.host, u.port)
    if !sock.open then
        empty_res.error = "Connection failed to " + u.host
        return empty_res
    end
    
    let sent: NetResult = socket_send(sock, req_data)

    if !sent.ok then
        socket_close(sock)
        empty_res.error = "Failed to send request: " + sent.error
        return empty_res
    end
    
    let read_res: NetResult = read_all(sock, client.timeout_ms)
    socket_close(sock)
    
    if !read_res.ok && read_res.count == 0 then
        empty_res.error = "Failed to read response: " + read_res.error
        return empty_res
    end
    
    if read_res.count == 0 then
        empty_res.error = "Empty response from server"
        return empty_res
    end
    
    let http_res: HttpResponse = parse_response(read_res.data, read_res.count)
    
    let ok: bool = http_res.status_code >= 200 && http_res.status_code < 300
    let err_msg: string = ""
    if !ok then
        err_msg = http_res.status_text
        if err_msg == "" then
            err_msg = "HTTP Status " + to_str(http_res.status_code)
        end
    end
    
    return ClientResponse(ok, http_res.status_code, http_res.headers, http_res.header_count, http_res.body, err_msg)
end

func get(url: string) -> ClientResponse
    let h: string[64]
    return request(default_client, "GET", url, h, 0, b"")
end

func post(url: string, body: bytes) -> ClientResponse
    let h: string[64]
    h[0] = "Content-Type: application/json"
    return request(default_client, "POST", url, h, 1, body)
end

func put(url: string, body: bytes) -> ClientResponse
    let h: string[64]
    h[0] = "Content-Type: application/json"
    return request(default_client, "PUT", url, h, 1, body)
end

func delete(url: string) -> ClientResponse
    let h: string[64]
    return request(default_client, "DELETE", url, h, 0, b"")
end

func patch(url: string, body: bytes) -> ClientResponse
    let h: string[64]
    h[0] = "Content-Type: application/json"
    return request(default_client, "PATCH", url, h, 1, body)
end
