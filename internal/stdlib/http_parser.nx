// stdlib/http_parser.nx - Optimal HTTP Parser
use strings select *

// ============================================
// Structures
// ============================================

struct HttpRequest
    method: string,
    path: string,
    query: string,
    version: string,
    headers: string[64],
    header_count: int,
    body: bytes
end

struct HttpResponse
    version: string,
    status_code: int,
    status_text: string,
    headers: string[64],
    header_count: int,
    body: bytes
end

struct HttpUrl
    scheme: string,
    host: string,
    port: int,
    path: string,
    query: string,
    fragment: string,
    valid: bool
end

// ============================================
// Constants
// ============================================

let HTTP_200_OK: int = 200
let HTTP_404_NOT_FOUND: int = 404
let HTTP_500_INTERNAL_ERROR: int = 500

func get_status_text(code: int) -> string
    if code == 200 then return "OK" end
    if code == 201 then return "Created" end
    if code == 204 then return "No Content" end
    if code == 400 then return "Bad Request" end
    if code == 401 then return "Unauthorized" end
    if code == 403 then return "Forbidden" end
    if code == 404 then return "Not Found" end
    if code == 500 then return "Internal Server Error" end
    return "Unknown"
end

// ============================================
// Parse Helpers
// ============================================

// Scan for \r\n\r\n (13, 10, 13, 10)
func find_header_end(data: bytes, len: int) -> int
    let i: int = 0
    let limit: int = len - 3
    
    while i < limit do
        if data[i] == 13 then
            if data[i+1] == 10 then
                if data[i+2] == 13 then
                    if data[i+3] == 10 then
                        return i
                    end
                end
            end
        end
        i = i + 1
    end
    return -1
end

// ============================================
// URL Parser
// ============================================

func parse_url(url: string) -> HttpUrl
    // Default
    let res: HttpUrl = HttpUrl("http", "", 80, "/", "", "", false)
    if length(url) == 0 then return res end
    
    let current: string = url
    
    // 1. Scheme
    let split_scheme: SplitResult = split(current, "://")
    if split_scheme.count > 1 then
        res.scheme = split_scheme.parts[0]
        current = split_scheme.parts[1]
    end
    
    if res.scheme == "https" then res.port = 443 end
    
    // 2. Fragment (#)
    let split_frag: SplitResult = split(current, "#")
    if split_frag.count > 1 then
        res.fragment = split_frag.parts[1]
        current = split_frag.parts[0]
    end
    
    // 3. Query (?)
    let split_query: SplitResult = split(current, "?")
    if split_query.count > 1 then
        res.query = split_query.parts[1]
        current = split_query.parts[0]
    end
    
    // 4. Authority vs Path
    // Find first /
    let slash_idx: int = index_of(current, "/")
    let authority: string = ""
    
    if slash_idx == -1 then
        authority = current
        res.path = "/"
    else
        authority = substring(current, 0, slash_idx)
        res.path = substring(current, slash_idx, length(current))
    end
    
    // 5. Host:Port
    let split_port: SplitResult = split(authority, ":")
    if split_port.count > 1 then
        res.host = split_port.parts[0]
        res.port = to_int(split_port.parts[1])
    else
        res.host = authority
    end
    
    res.valid = true
    return res
end

// ============================================
// Request Parser
// ============================================

func parse_request(data: bytes, len: int) -> HttpRequest
    // Strategy: Find Double CRLF. Split everything before into lines. Everything after is body.
    let end_headers: int = find_header_end(data, len)
    let body_start: int = 0
    let header_bytes: bytes = b""
    
    if end_headers == -1 then
        // Specific case: No headers end found. Assume all content is header data for robustness.
        header_bytes = data
        body_start = len
    else
        header_bytes = slice(data, 0, end_headers)
        body_start = end_headers + 4
    end
    
    let empty_h: string[64]
    let req: HttpRequest = HttpRequest("GET", "/", "", "HTTP/1.1", empty_h, 0, b"")
    
    if body_start < len then
        req.body = slice(data, body_start, len)
    end
    
    // Bytes -> String for headers
    // Warning: Binary data in headers is illegal anyway, so safe to convert.
    let header_str: string = to_str(header_bytes)
    
    // Split by \r\n
    // Note: 'split' consumes memory for array. 
    let lines: SplitResult = split(header_str, "\r\n")
    
    if lines.count > 0 then
        // Request Line
        let req_line: string = lines.parts[0]
        let req_parts: SplitResult = split(req_line, " ")
        if req_parts.count > 0 then req.method = req_parts.parts[0] end
        if req_parts.count > 1 then 
            let full_path: string = req_parts.parts[1]
            let q_split: SplitResult = split(full_path, "?")
            req.path = q_split.parts[0]
            if q_split.count > 1 then req.query = q_split.parts[1] end
        end
        if req_parts.count > 2 then req.version = req_parts.parts[2] end
        
        // Headers
        let i: int = 1
        while i < lines.count do
            let line: string = lines.parts[i]
            if length(line) > 0 then
                if req.header_count < 64 then
                    req.headers[req.header_count] = line
                    req.header_count = req.header_count + 1
                end
            end
            i = i + 1
        end
    end
    
    return req
end

func parse_response(data: bytes, len: int) -> HttpResponse
    let empty_h: string[64]
    let end_headers: int = find_header_end(data, len)
    let body_start: int = 0
    let header_bytes: bytes = b""
    
    if end_headers == -1 then
        header_bytes = data
        body_start = len
    else
        header_bytes = slice(data, 0, end_headers)
        body_start = end_headers + 4
    end
    
    let resp: HttpResponse = HttpResponse("HTTP/1.1", 200, "OK", empty_h, 0, b"")
    
    if body_start < len then
        resp.body = slice(data, body_start, len)
    end
    
    let header_str: string = to_str(header_bytes)
    let lines: SplitResult = split(header_str, "\r\n")
    
    if lines.count > 0 then
        // Status Line: HTTP/1.1 200 OK
        let status_line: string = lines.parts[0]
        let s_parts: SplitResult = split(status_line, " ")
        if s_parts.count > 0 then resp.version = s_parts.parts[0] end
        if s_parts.count > 1 then resp.status_code = to_int(s_parts.parts[1]) end
        
        if s_parts.count > 2 then
             // Reconstruct status text from remaining parts.
             let txt: string = ""
             let k: int = 2
             while k < s_parts.count do
                 if k > 2 then txt = txt + " " end
                 txt = txt + s_parts.parts[k]
                 k = k + 1
             end
             resp.status_text = txt
        end
        
        // Headers
        let i: int = 1
        while i < lines.count do
             let line: string = lines.parts[i]
             if length(line) > 0 then
                 if resp.header_count < 64 then
                     resp.headers[resp.header_count] = line
                     resp.header_count = resp.header_count + 1
                 end
             end
             i = i + 1
        end
    end
    
    return resp
end

// ============================================
// Builders
// ============================================

func build_request(method: string, path: string, headers: string[64], count: int, body: bytes) -> bytes
    let head: string = method + " " + path + " HTTP/1.1\r\n"
    let i: int = 0
    while i < count do
        head = head + headers[i] + "\r\n"
        i = i + 1
    end
    head = head + "\r\n"
    return to_bytes(head) + body
end

func build_response(code: int, text: string, headers: string[64], count: int, body: bytes) -> bytes
    let head: string = "HTTP/1.1 " + to_str(code) + " " + text + "\r\n"
    let i: int = 0
    while i < count do
        head = head + headers[i] + "\r\n"
        i = i + 1
    end
    head = head + "\r\n"
    return to_bytes(head) + body
end

// ============================================
// Header Utils
// ============================================

func get_header(headers: string[64], count: int, name: string) -> string
    let search: string = strings_to_lower(name) + ":"
    let i: int = 0
    while i < count do
        let h: string = strings_to_lower(headers[i])
        if strings_starts_with(h, search) then
            // Found. Now need original value.
            let orig: string = headers[i]
            let parts: SplitResult = split(orig, ":")
            if parts.count > 1 then
                // Return trimmed value after the first colon.
                return strings_trim(parts.parts[1]) 
            end
        end
        i = i + 1
    end
    return ""
end
