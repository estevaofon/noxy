// Módulo Crypto para Noxy
// Implementa SHA-256 e helpers

// Constantes K para SHA-256
let K: int[] = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]



// Simula Right Rotate para 32-bit
func rotr(x: int, n: int) -> int
    return ((x >> n) | (x << (32 - n))) & 0xFFFFFFFF
end

// Funções auxiliares do SHA-256
func ch(x: int, y: int, z: int) -> int
    return (x & y) ^ ((~x) & z)
end

func maj(x: int, y: int, z: int) -> int
    return (x & y) ^ (x & z) ^ (y & z)
end

func sum0(x: int) -> int
    return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22)
end

func sum1(x: int) -> int
    return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25)
end

func sigma0(x: int) -> int
    return rotr(x, 7) ^ rotr(x, 18) ^ ((x >> 3) & 0xFFFFFFFF)
end

func sigma1(x: int) -> int
    return rotr(x, 17) ^ rotr(x, 19) ^ ((x >> 10) & 0xFFFFFFFF)
end

func sha256(data_input: bytes) -> string
    // 1. Padding
    // Copia dados para array de bytes mutável (representado como array de inteiros para manipulação)
    let msg: int[] = []
    let L: int = length(data_input)
    let i: int = 0
    while i < L do
        append(msg, data_input[i])
        i = i + 1
    end

    // Append '1' bit (0x80 byte)
    append(msg, 0x80)

    // Append k '0' bits (k '0'/256 bytes)
    // Mensagem deve ser M.l + 1 + k = 448 mod 512
    // Em bytes: bytes_len + 1 + pad = 56 mod 64
    let current_len: int = length(msg)
    while (current_len % 64) != 56 do
        append(msg, 0)
        current_len = length(msg)
    end

    // Append length L como 64-bit big-endian integer
    // L é em bytes, mas o protocolo requer L em bits.
    let bit_len: int = L * 8
    
    // Low 32 bits
    let low_bits: int = bit_len & 0xFFFFFFFF
    // High 32 bits
    let high_bits: int = (bit_len >> 32) & 0xFFFFFFFF

    // Append 8 bytes big endian
    append(msg, (high_bits >> 24) & 0xFF)
    append(msg, (high_bits >> 16) & 0xFF)
    append(msg, (high_bits >> 8) & 0xFF)
    append(msg, high_bits & 0xFF)
    
    append(msg, (low_bits >> 24) & 0xFF)
    append(msg, (low_bits >> 16) & 0xFF)
    append(msg, (low_bits >> 8) & 0xFF)
    append(msg, low_bits & 0xFF)

    // 2. Hash computation
    
    // Hash Values (H)
    let h0: int = 0x6a09e667
    let h1: int = 0xbb67ae85
    let h2: int = 0x3c6ef372
    let h3: int = 0xa54ff53a
    let h4: int = 0x510e527f
    let h5: int = 0x9b05688c
    let h6: int = 0x1f83d9ab
    let h7: int = 0x5be0cd19

    // Processar chunks de 64 bytes (16 palavras de 32 bits)
    let num_chunks: int = length(msg) / 64
    let chunk_idx: int = 0
    
    // Buffer W (Schedule) de 64 ints
    let W: int[64]

    while chunk_idx < num_chunks do
        let offset: int = chunk_idx * 64
        
        // 1. Prepare message schedule W
        let t: int = 0
        while t < 16 do
            // Combinar 4 bytes em 1 int (big-endian)
            let b1: int = msg[offset + t*4]
            let b2: int = msg[offset + t*4 + 1]
            let b3: int = msg[offset + t*4 + 2]
            let b4: int = msg[offset + t*4 + 3]
            W[t] = ((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) & 0xFFFFFFFF
            t = t + 1
        end
        while t < 64 do
            let s1: int = sigma1(W[t-2])
            let s0: int = sigma0(W[t-15])
            let sum: int = s1 + W[t-7] + s0 + W[t-16]
            W[t] = sum & 0xFFFFFFFF
            t = t + 1
        end

        // 2. Initialize working variables
        let a: int = h0
        let b: int = h1
        let c: int = h2
        let d: int = h3
        let e: int = h4
        let f: int = h5
        let g: int = h6
        let h: int = h7

        // 3. Main loop
        t = 0
        while t < 64 do
            let S1: int = sum1(e)
            let ch_val: int = ch(e, f, g)
            let temp1: int = (h + S1 + ch_val + K[t] + W[t]) & 0xFFFFFFFF
            let S0: int = sum0(a)
            let maj_val: int = maj(a, b, c)
            let temp2: int = (S0 + maj_val) & 0xFFFFFFFF

            h = g
            g = f
            f = e
            e = (d + temp1) & 0xFFFFFFFF
            d = c
            c = b
            b = a
            a = (temp1 + temp2) & 0xFFFFFFFF
            
            t = t + 1
        end

        // 4. Add to hash values
        h0 = (h0 + a) & 0xFFFFFFFF
        h1 = (h1 + b) & 0xFFFFFFFF
        h2 = (h2 + c) & 0xFFFFFFFF
        h3 = (h3 + d) & 0xFFFFFFFF
        h4 = (h4 + e) & 0xFFFFFFFF
        h5 = (h5 + f) & 0xFFFFFFFF
        h6 = (h6 + g) & 0xFFFFFFFF
        h7 = (h7 + h) & 0xFFFFFFFF

        chunk_idx = chunk_idx + 1
    end

    // Produzir string hex final
    return fmt("%08x%08x%08x%08x%08x%08x%08x%08x", h0, h1, h2, h3, h4, h5, h6, h7)
end

// ============================================
// Funções de Criptografia Simétrica (Nativas)
// ============================================

// Gera n bytes criptograficamente seguros
func random_bytes(n: int) -> bytes
    return crypto_random_bytes(n)
end

// Deriva chave usando PBKDF2 com HMAC-SHA256
func pbkdf2_sha256(senha: string, salt: bytes, iteracoes: int, tamanho: int) -> bytes
    return crypto_pbkdf2_sha256(senha, salt, iteracoes, tamanho)
end

// Criptografa com AES-256-GCM (retorna nonce + ciphertext + tag)
func aes256_gcm_encrypt(chave: bytes, texto: bytes) -> bytes
    return crypto_aes256_gcm_encrypt(chave, texto)
end

// Descriptografa AES-256-GCM (valida autenticação)
func aes256_gcm_decrypt(chave: bytes, dados: bytes) -> bytes
    return crypto_aes256_gcm_decrypt(chave, dados)
end
