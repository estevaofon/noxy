// stdlib/json_parser.nx
// JSON Parser & Stringifier

// ============================================
// Types
// ============================================

let TYPE_NULL: int = 0
let TYPE_BOOL: int = 1
let TYPE_NUMBER: int = 2
let TYPE_STRING: int = 3
let TYPE_ARRAY: int = 4
let TYPE_OBJECT: int = 5

struct JsonNode
    type: int,
    bool_val: bool,
    number_val: float,
    string_val: string,
    key: string,
    child: ref JsonNode,
    next: ref JsonNode
end

struct Parser
    source: string,
    pos: int,
    len: int
end

// ============================================
// Factories
// ============================================

func make_null() -> JsonNode
    return JsonNode(TYPE_NULL, false, 0.0, "", "", null, null)
end

func make_bool(val: bool) -> JsonNode
    return JsonNode(TYPE_BOOL, val, 0.0, "", "", null, null)
end

func make_number(val: float) -> JsonNode
    return JsonNode(TYPE_NUMBER, false, val, "", "", null, null)
end

func make_string(val: string) -> JsonNode
    return JsonNode(TYPE_STRING, false, 0.0, val, "", null, null)
end

func make_array() -> JsonNode
    return JsonNode(TYPE_ARRAY, false, 0.0, "", "", null, null)
end

func make_object() -> JsonNode
    return JsonNode(TYPE_OBJECT, false, 0.0, "", "", null, null)
end

// ============================================
// Helper Utils
// ============================================

func append_child(parent: ref JsonNode, child: ref JsonNode) -> void
    if parent.child == null then
        parent.child = child
    else
        let current: ref JsonNode = parent.child
        while current.next != null do
            current = current.next
        end
        current.next = child
    end
end

// ============================================
// Parser Implementation
// ============================================

func is_at_end(p: ref Parser) -> bool
    return p.pos >= p.len
end

func peek(p: ref Parser) -> string
    if p.pos >= p.len then return "" end
    return p.source[p.pos]
end

func advance(p: ref Parser) -> string
    if p.pos >= p.len then return "" end
    let c: string = p.source[p.pos]
    p.pos = p.pos + 1
    return c
end

func skip_whitespace(p: ref Parser) -> void
    let c: string = peek(p)
    // Basic whitespace check: space, \n, \t, \r
    while !is_at_end(p) && (c == " " || c == "\n" || c == "\t" || c == "\r") do
        let ignored: string = advance(p)
        c = peek(p)
    end
end

func parse_string_val(p: ref Parser) -> string
    let quote: string = advance(p) // Assume caller checked quote
    let res: string = ""
    
    while !is_at_end(p) do
        let c: string = peek(p)
        if c == "\\" then
            let ign: string = advance(p) // skip slash
            if !is_at_end(p) then
                let esc: string = advance(p)
                // Handle basic escapes
                if esc == "\"" then res = res + "\"" end
                if esc == "\\" then res = res + "\\" end
                if esc == "/" then res = res + "/" end
                if esc == "n" then res = res + "\n" end
                if esc == "r" then res = res + "\r" end
                if esc == "t" then res = res + "\t" end
                // Unicode \u not supported in MVP
            end
        else
            if c == "\"" then
                let ign: string = advance(p)
                return res
            end
            res = res + advance(p)
        end
    end
    return res
end

func parse_number_val(p: ref Parser) -> float
    let start: int = p.pos
    let c: string = peek(p)
    if c == "-" then let ign: string = advance(p) end
    
    while !is_at_end(p) do
        let d: string = peek(p)
        let code: int = ord(d)
        if (code >= 48 && code <= 57) || d == "." || d == "e" || d == "E" || d == "+" || d == "-" then
            let ign: string = advance(p)
        else
            break
        end
    end
    // Extract substring logic? No substring helper here natively unless we import strings.
    // Manual reconstruction not ideal. "parse_number" usually primitive.
    // Noxy to_float parses string.
    // We need to slice the string source.
    // Assuming simple slice or reconstruction.
    // Since we don't have slice on strings easily exposed without strings module,
    // let's accumulate in string during scan (slower but works).
    
    // Restart scan for extraction (optimization: do it in one pass above)
    // Actually, let's just accumulate above.
    return 0.0 // Placeholder if we don't extract.
end

// Redoing number parse with accumulation
func parse_number_str(p: ref Parser) -> float
    let res: string = ""
    let c: string = peek(p)
    
    if c == "-" then 
        res = res + advance(p) 
    end
    
    // Int part
    while !is_at_end(p) do
        let d: string = peek(p)
        let code: int = ord(d)
        if code >= 48 && code <= 57 then
            res = res + advance(p)
        else
            break
        end
    end
    
    // Fraction
    if peek(p) == "." then
        res = res + advance(p)
        while !is_at_end(p) do
             let d: string = peek(p)
             let code: int = ord(d)
             if code >= 48 && code <= 57 then
                 res = res + advance(p)
             else
                 break
             end
        end
    end
    
    return to_float(res)
end

// Recursion needs forward declaration or order? order matters in Noxy? 
// Noxy allows recursion if function is defined. 
// Mutual recursion needs careful ordering or prototype? 
// Noxy currently reads file linearly? No, it parses definitions. Recursion is fine.

func parse_value(p: ref Parser) -> ref JsonNode
    skip_whitespace(p)
    let c: string = peek(p)
    
    if c == "{" then return parse_object(p) end
    if c == "[" then return parse_array(p) end
    if c == "\"" then return ref make_string(parse_string_val(p)) end
    if c == "t" then 
        // true
        let ign: string = advance(p) 
        ign = advance(p) // r
        ign = advance(p) // u
        ign = advance(p) // e
        return ref make_bool(true)
    end
    if c == "f" then
        // false
        let ign: string = advance(p)
        ign = advance(p) // a
        ign = advance(p) // l
        ign = advance(p) // s
        ign = advance(p) // e
        return ref make_bool(false)
    end
    if c == "n" then
        // null
        let ign: string = advance(p)
        ign = advance(p) // u
        ign = advance(p) // l
        ign = advance(p) // l
        return ref make_null()
    end
    
    // Number
    let code: int = ord(c)
    if c == "-" || (code >= 48 && code <= 57) then
        return ref make_number(parse_number_str(p))
    end
    
    return ref make_null() // Error
end

func parse_array(p: ref Parser) -> ref JsonNode
    let arr: ref JsonNode = ref make_array()
    let ign: string = advance(p) // [
    
    skip_whitespace(p)
    if peek(p) == "]" then
        ign = advance(p)
        return arr
    end
    
    while true do
        let val: ref JsonNode = parse_value(p)
        append_child(arr, val)
        skip_whitespace(p)
        if peek(p) == "]" then
            ign = advance(p)
            break
        end
        if peek(p) == "," then
            ign = advance(p)
        else
            break
        end
    end
    return arr
end

func parse_object(p: ref Parser) -> ref JsonNode
    let obj: ref JsonNode = ref make_object()
    let ign: string = advance(p) // {
    
    skip_whitespace(p)
    if peek(p) == "}" then
        ign = advance(p)
        return obj
    end
    
    while true do
        skip_whitespace(p)
        let key: string = parse_string_val(p)
        skip_whitespace(p)
        if peek(p) == ":" then ign = advance(p) end
        
        let val: ref JsonNode = parse_value(p)
        val.key = key
        append_child(obj, val)
        
        skip_whitespace(p)
        if peek(p) == "}" then
            ign = advance(p)
            break
        end
        if peek(p) == "," then
            ign = advance(p)
        else
            break
        end
    end
    return obj
end

func json_parse(json: string) -> ref JsonNode
    let p: Parser = Parser(json, 0, length(json))
    return parse_value(p)
end

// ============================================
// Stringify
// ============================================

func json_stringify(node: ref JsonNode) -> string
    if node == null then return "null" end
    
    if node.type == TYPE_NULL then return "null" end
    if node.type == TYPE_BOOL then 
        if node.bool_val then return "true" else return "false" end
    end
    if node.type == TYPE_NUMBER then return to_str(node.number_val) end
    if node.type == TYPE_STRING then return "\"" + node.string_val + "\"" end // Need escape impl
    
    if node.type == TYPE_ARRAY then
        let res: string = "["
        let curr: ref JsonNode = node.child
        let first: bool = true
        while curr != null do
            if !first then res = res + "," end
            res = res + json_stringify(curr)
            first = false
            curr = curr.next
        end
        return res + "]"
    end
    
    if node.type == TYPE_OBJECT then
        let res: string = "{"
        let curr: ref JsonNode = node.child
        let first: bool = true
        while curr != null do
            if !first then res = res + "," end
            res = res + "\"" + curr.key + "\":" + json_stringify(curr)
            first = false
            curr = curr.next
        end
        return res + "}"
    end
    
    return ""
end